* Send our full contact details at the end of handshake
* Handshake if we are given a livewire URI. Ask the other end for their full key (livewire URL to only have fingerprint), giving them our at the same time. Then send them our full contact details once we hae theirs
* Handle simple encrypted text messages
* Write demo apps relaxed and drawing app and wall app and cello
* Write BDD tests
* Have two parties in a conversation successfully request missing edges.
* Required edges received off the net to be signed by a known contact
* Make testing server thread safe by replacing Dict with FrozenDict
* Demux plain email don't include the full name of the sender
* Test we receive normal emails OK including not sending confirmation emails
* Make sure the Demux saves and reloads our info correctly on program restart
* Require encoded messages to be signed
* Remove tests that manually handshake and send encrypted messages and use a Demux instead
* testingmailserver.ResetMailDict() is used too often in tests somehow deleting things is not working correctly
* Changes made while frozen should not be shared
* fromrawbodytest should accept a list of lines not a single string. Also maybe the full version of this function should be used
* documentcollection is used by HistoryEdgeAddChild to lookup the class when replaying. Should this info be stored elsewhere (eg in the history graph)
* test saving multiple objects (both mutable and imutable in a database)
* add chains of mutable objects. So we can record events and know we have the correct sequence
* check mockpoplib is correctly emulating the behaviour of real email
* Remove sqlite for the messagestore and use our own document structures
* change ReceiveEmailByPOPTestCase and SendEmailBySMTPTestCase to use the demux
* Demux needs to be able to save to a file

Currently Working on

Finished
* Remove global variables from the old app MessageStore and place in the Demux class
* In document collection objects should be a dict of dicts not a dict of lists
* Remove the DocumentCollection.documentcollection global
* BDD harness finished in lettuce
* Make sure the demux correctly handles multiple queued up emails
* Add unit tests to test edge listener functionality of both documents and collections
* Test sharing of immutable objects
* Handle app routing of messages (we receive a message on the wire intended for an app how do we send it)
* Ensure apps can send out updates of shared data.
* Update handling including when edges are replayed
* Store ImmutableObjects in database
* Transmit ImmutableObject via JSON
* Add support for imutable data records ie things that would record information from sensor at a certain time. Temp at 1pm is 26c
* Test that a three way merge works. Ie produce a graph with three dangling edges and replay it to produce the correct result
* DocumentObject __setattr__ only needs to skip on insetattr other are filtered out by doop fields
* Test performance of merging hundreds of edges
* Change AddEdge functions to addedges and send edges around in groups for performance reasons
* Change startnode and endnode addressess to be hashes
* Change md5 hashes to sha256
* Add a more realistic way of sending edges around. This would involve sending edges and adding them to a a document and detecting dangling edges and ophaned edges and whatever odd scnarios happen
* Test receiving an unplayable edge that is not a merge edge with a missing startnode
* Add the ability to freeze edges - this is from the traingles app

On Hold
* createdocumentcollection message creates a document without asking the user for permission
* Documents with no activity cannot be shared. This may or may not be a problem
* Make edge reversible so we can get back to data that used to exist
* Stop directly accessing the history graph access it via methods on the Document class
* Put special DOOP fields into a Meta class as per Django Models
* Replaying the graph has a pattern like ProcessGraph, RecordPastEdges, ProcessConflictWinners, Replay see Document.Unfreeze clean this up and make one function
* Add transactions, we could store them in edges with multiple commands to reduce metadata requirements

Rejected
* Switch to SQLite JSON storage - SQLite's JSON storage appears to be too combersome for this for now. Relational is good enough



